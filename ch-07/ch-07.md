# 第7章 贪心算法

5. 假设在$0/1$背包问题中，按重量递增所排的物品次序与按价值递减所排的次序一样，请给出求这种背包问题最优解的有效算法，并分析其正确性。

**ANSWER:**

~~~vb
GreedyKnapsack(S, W)
    w = 0
    A = ∅
    for i = 1 to n do
        if w + w[i] <= W then
            w = w + w[i]
            A = A ∪ {s[i]}
    return
~~~

- 贪心选择性质证明

  假设子问题$S$的最优装载方案为$A$。设$s_k$为$A$中的下标最小的物品,$s_m$为$S$中的下标最小的物品。从$A$中去掉$s_k$，然后加入$s_{m}$可以得到一个新的装载方案$A'=\{A-\{s_k\}\}\cup\{s_m\}$。

  因为

  $$w_m\leq w_k,v_m\geq v_k,$$

  所以

  $$w(A')\leq w(A) \leq W, v(A')\geq v(A),$$
  故$A'$也是子问题$S$的一个最优装载方案。

- 最优子结构性质证明

  假设子问题$S$的最优装载方案为$A$。则$A''=A /\ s_i$是子问题$S''=S /\ s_i$的最优装载方案。如果$A''$不是$S''=S /\ s_i$的最优装载方案，则可以通过优化$A''$来优化$A$，这与假设矛盾。


8. 将哈夫曼编码推广至三进制编码(即用符号$0$，$1$，$2$，来编码)，并证明他能产生最优三进制编码。

**ANSWER:**

~~~vb
GeneralizedHuffmanCode(C)
    Q = C
    for i = 1 to n - 1 do
        allocate a new node z
        w = ExtractMin(Q)
        x = ExtractMin(Q)
        y = ExtractMin(Q)
        f(z) = f(w) + f(x) + f(y)
        Insert(Q, z)
    return ExtractMin(Q)
~~~

- 证明

  我们将证明任何最优树在最低级别具有最低的三个频率。假设没有。我们可以用最低的3个叶子中的一个从最低级别切换一个叶子，并获得较低的平均长度。在不失一般性的情况下，我们可以假定所有三个最低频率都是同一个节点的孩子。 （如果它们处于同一水平，平均长度不会改变，不管频率在哪里）
  现在观察一下，我们可以把收缩的叶子当作一个等于三个字符频率之和的新字符。通过类似于二进制霍夫曼编码给出的推理，我们可以看到最优树的代价是收缩的三个符号的树和收缩之前的节点的消除的迷你树的总和。由于已经证明迷你树必须存在于最终的最优树中，所以我们可以以收缩节点方式对树进行优化。

9. 假设海岸是一条直线，陆地在海平面的一边有很多小岛(每个小岛可看作里面的一个点)。在海岸上可布置若干雷达，每个雷达的控制范围为$d$，即如果小岛离雷达距离不超过$d$，那么小岛就在雷达的控制范围之内，如图$7.11$所示。假设$x$轴表示海岸，海在$x$轴上面，小岛用坐标$(x, y)$表示，给定一些小岛的坐标和雷达的控制距离$d$，求所需要的最少雷达数。$(POJ1328)$

**ANSWER:**

![](/home/bigding/Code/algorithm-design-and-analysis-homework/ch-07/ch-07-00.jpg)

从左到右建立雷达，要尽量多地覆盖岛屿。以岛屿为圆心，以d为半径画圆，如果画出的圆与x轴没有交点，则不能实现。存在交点的话，计算出第i个岛屿与x轴的交点坐标保存在结构体数组rad[i].sta与rad[i].end中。对结构体数组排序，按照rad[i].end进行升序排列，然后一次从左到右找雷达。对于rad[i].end为当前最右边的左坐标，对于下一个岛屿，如果rad[j].sta<ran[i].end，则不需要建立新的雷达，需要更新下一个岛屿。否则需要建立新的雷达。